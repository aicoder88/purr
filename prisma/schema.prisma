// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client"
  output   = "../src/generated/client"
  binaryTargets = ["native", "rhel-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
}

model User {
  id            String     @id @default(cuid())
  name          String?
  email         String?    @unique
  emailVerified DateTime?
  image         String?
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt
  lastLoginAt   DateTime?
  accounts      Account[]
  sessions      Session[]
  orders        Order[]
  referrals     Referral[] @relation("Referrer")
  referredBy    Referral[] @relation("Referee")
  // Referral program relations
  referralCode  ReferralCode?
  referralRewards ReferralReward[]

  @@index([email])
  @@index([createdAt])
}

model Retailer {
  id               String           @id @default(cuid())
  businessName     String
  contactName      String
  email            String           @unique
  phone            String?
  password         String // Hashed with bcrypt
  status           RetailerStatus   @default(PENDING)
  approvedAt       DateTime?
  approvedBy       String? // Admin user ID
  taxId            String? // Business tax ID
  shippingAddress  ShippingAddress?
  billingAddress   BillingAddress?
  orders           RetailerOrder[]
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt
  lastLoginAt      DateTime?
  stripeCustomerId String?          @unique // Stripe customer ID for B2B payments
  notes            String?          @db.Text // Admin notes

  @@index([email])
  @@index([status])
  @@index([createdAt])
  @@map("retailers")
}

enum RetailerStatus {
  PENDING // Awaiting approval
  ACTIVE // Approved and can order
  SUSPENDED // Temporarily disabled
  REJECTED // Application rejected
}

model ShippingAddress {
  id         String   @id @default(cuid())
  street     String
  city       String
  province   String
  postalCode String
  country    String   @default("CA")
  retailer   Retailer @relation(fields: [retailerId], references: [id], onDelete: Cascade)
  retailerId String   @unique
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@map("shipping_addresses")
}

model BillingAddress {
  id         String   @id @default(cuid())
  street     String
  city       String
  province   String
  postalCode String
  country    String   @default("CA")
  retailer   Retailer @relation(fields: [retailerId], references: [id], onDelete: Cascade)
  retailerId String   @unique
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@map("billing_addresses")
}

model RetailerOrder {
  id                    String              @id @default(cuid())
  orderNumber           String              @unique // Human-readable order number (e.g., RO-2025-001)
  retailer              Retailer            @relation(fields: [retailerId], references: [id])
  retailerId            String
  status                RetailerOrderStatus @default(PENDING)
  subtotal              Float // Before tax
  tax                   Float
  shipping              Float
  totalAmount           Float // Final total
  items                 RetailerOrderItem[]
  stripeSessionId       String?             @unique
  stripePaymentIntentId String?             @unique
  trackingNumber        String?
  shippingCarrier       String?
  shippedAt             DateTime?
  deliveredAt           DateTime?
  notes                 String?             @db.Text
  createdAt             DateTime            @default(now())
  updatedAt             DateTime            @updatedAt

  @@index([retailerId])
  @@index([status])
  @@index([createdAt])
  @@index([orderNumber])
  @@map("retailer_orders")
}

enum RetailerOrderStatus {
  PENDING // Order created, awaiting payment
  PAID // Payment received
  PROCESSING // Being prepared
  SHIPPED // Shipped to retailer
  DELIVERED // Delivered
  CANCELLED // Cancelled
  REFUNDED // Refunded
}

model RetailerOrderItem {
  id         String        @id @default(cuid())
  order      RetailerOrder @relation(fields: [orderId], references: [id], onDelete: Cascade)
  orderId    String
  product    Product       @relation(fields: [productId], references: [id])
  productId  String
  quantity   Int
  unitPrice  Float // Wholesale price
  totalPrice Float // quantity * unitPrice
  createdAt  DateTime      @default(now())

  @@index([orderId])
  @@index([productId])
  @@map("retailer_order_items")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Product {
  id                 String              @id @default(cuid())
  name               String
  description        String
  price              Float // Consumer price
  wholesalePrice     Float? // Wholesale/retailer price
  minimumOrder       Int? // Minimum order quantity for retailers
  image              String
  // Inventory tracking
  stockQuantity      Int                 @default(0) // Current stock level
  lowStockThreshold  Int                 @default(10) // Alert when below this
  sku                String?             @unique // Stock keeping unit
  trackInventory     Boolean             @default(true) // Enable inventory tracking
  lastRestockedAt    DateTime? // When stock was last added
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  orderItems         OrderItem[]
  retailerOrderItems RetailerOrderItem[]
  subscriptionItems  SubscriptionItem[]

  @@index([stockQuantity, lowStockThreshold]) // For low stock queries
}

model Order {
  id                String      @id @default(cuid())
  totalAmount       Float       @map("total") // Renamed for clarity
  currency          String      @default("CAD") // Currency: 'CAD' or 'USD'
  status            OrderStatus @default(PENDING) // Use enum for better type safety
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt
  userId            String?
  stripeSessionId   String?     @unique // Track Stripe sessions
  user              User?       @relation(fields: [userId], references: [id])
  customer          Customer?
  items             OrderItem[]
  referral          Referral?
  subscription      Subscription? @relation(fields: [subscriptionId], references: [id])
  subscriptionId    String?
  // Review request tracking for post-purchase emails
  reviewRequestSent Boolean     @default(false)
  reviewRequestAt   DateTime?
  // UTM Attribution tracking
  utmSource         String? // Traffic source (google, facebook, etc.)
  utmMedium         String? // Medium (cpc, email, social)
  utmCampaign       String? // Campaign name
  utmTerm           String? // Search keywords
  utmContent        String? // Ad variant
  utmLandingPage    String? // First page visited
  utmCapturedAt     DateTime? // When UTM was captured
  // Referral discount tracking
  referralCodeUsed  String? // Referral code applied at checkout
  referralDiscount  Float?  // Discount amount from referral ($5)
  // Affiliate tracking
  affiliateCode     String? // Affiliate code that referred this order

  @@index([status])
  @@index([createdAt])
  @@index([stripeSessionId])
  @@index([reviewRequestSent, status]) // For finding orders needing review requests
  @@index([utmSource, utmCampaign]) // For UTM attribution queries
  @@index([subscriptionId])
  @@index([referralCodeUsed])
  @@index([affiliateCode])
  @@index([currency])
}

enum OrderStatus {
  PENDING
  PROCESSING
  PAID
  SHIPPED
  DELIVERED
  CANCELLED
  REFUNDED
}

model Customer {
  id         String   @id @default(cuid())
  email      String // Should be encrypted at application level
  firstName  String // Should be encrypted at application level
  lastName   String // Should be encrypted at application level
  address    String // Should be encrypted at application level
  city       String // Should be encrypted at application level
  province   String
  postalCode String // Should be encrypted at application level
  phone      String? // Should be encrypted at application level
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  order      Order    @relation(fields: [orderId], references: [id])
  orderId    String   @unique

  @@index([email])
  @@index([createdAt])
  @@map("customers") // Use consistent table naming
}

model OrderItem {
  id        String  @id @default(cuid())
  quantity  Int
  price     Float
  order     Order   @relation(fields: [orderId], references: [id])
  orderId   String
  product   Product @relation(fields: [productId], references: [id])
  productId String

  @@index([orderId])
  @@index([productId])
}

// Legacy Referral model (keep for backward compatibility)
model Referral {
  id         String         @id @default(cuid())
  code       String         @unique
  status     ReferralStatus @default(ACTIVE)
  createdAt  DateTime       @default(now())
  expiresAt  DateTime? // Optional expiration
  usageCount Int            @default(0)
  maxUsages  Int? // Optional usage limit
  commission Float? // Commission amount/percentage
  order      Order          @relation(fields: [orderId], references: [id])
  orderId    String         @unique
  referrer   User           @relation("Referrer", fields: [referrerId], references: [id])
  referrerId String
  referee    User           @relation("Referee", fields: [refereeId], references: [id])
  refereeId  String

  @@index([code])
  @@index([status])
  @@index([createdAt])
}

enum ReferralStatus {
  ACTIVE
  EXPIRED
  DISABLED
  USED
}

// ===== Sprint 6C: Referral Program Models =====

// ReferralCode - Unique shareable code per customer for "Give $5, Get $5" program
model ReferralCode {
  id            String   @id @default(cuid())
  code          String   @unique // e.g., "SARAH15-PURR"
  userId        String   @unique // One code per user
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  isActive      Boolean  @default(true)
  createdAt     DateTime @default(now())
  expiresAt     DateTime? // Optional expiration
  // Stats (denormalized for performance)
  totalClicks   Int      @default(0)
  totalSignups  Int      @default(0)
  totalOrders   Int      @default(0)
  totalEarnings Float    @default(0) // Total $5 credits earned
  // Redemptions
  redemptions   ReferralRedemption[]

  @@index([code])
  @@index([isActive])
  @@map("referral_codes")
}

// ReferralRedemption - Track when a referral code is used
model ReferralRedemption {
  id              String                   @id @default(cuid())
  referralCode    ReferralCode             @relation(fields: [referralCodeId], references: [id], onDelete: Cascade)
  referralCodeId  String
  // Referee (person who used the code)
  refereeEmail    String // Email of person who used the code
  refereeOrderId  String? // Order where code was applied
  // Status tracking
  status          ReferralRedemptionStatus @default(PENDING)
  // Rewards
  refereeDiscount Float                    @default(5.00) // $5 discount for referee
  referrerCredit  Float                    @default(5.00) // $5 credit for referrer
  // Timestamps
  clickedAt       DateTime? // When referral link was clicked
  signedUpAt      DateTime? // When referee signed up
  purchasedAt     DateTime? // When referee completed purchase
  rewardIssuedAt  DateTime? // When reward was issued to referrer
  createdAt       DateTime                 @default(now())
  updatedAt       DateTime                 @updatedAt

  @@index([referralCodeId])
  @@index([refereeEmail])
  @@index([status])
  @@index([createdAt])
  @@map("referral_redemptions")
}

enum ReferralRedemptionStatus {
  PENDING // Link clicked, awaiting purchase
  COMPLETED // Purchase completed, rewards issued
  EXPIRED // Referral expired (no purchase within time limit)
  CANCELLED // Referral cancelled (order refunded, etc.)
}

// ReferralReward - Track rewards/credits for referrers
model ReferralReward {
  id          String             @id @default(cuid())
  userId      String
  user        User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  amount      Float              @default(5.00) // $5 credit
  type        ReferralRewardType @default(REFERRAL_CREDIT)
  description String? // e.g., "Referral from john@example.com"
  status      ReferralRewardStatus @default(AVAILABLE)
  // Usage tracking
  usedOnOrderId String? // Order where reward was applied
  usedAt        DateTime?
  expiresAt     DateTime? // Optional expiration
  createdAt     DateTime @default(now())

  @@index([userId])
  @@index([status])
  @@index([expiresAt])
  @@map("referral_rewards")
}

enum ReferralRewardType {
  REFERRAL_CREDIT // $5 credit from successful referral
  MILESTONE_BONUS // Bonus for reaching milestones (5, 10, 25 referrals)
  PROMOTIONAL // Promotional credit
}

enum ReferralRewardStatus {
  AVAILABLE // Can be used
  USED // Already applied to an order
  EXPIRED // Expired without being used
  CANCELLED // Cancelled (fraud, etc.)
}

model AuditLog {
  id        String      @id @default(cuid())
  action    AuditAction
  entity    String // Table name (users, orders, etc.)
  entityId  String // Record ID
  userId    String? // User who performed the action
  ipAddress String? // IP address for security
  userAgent String? // Browser info
  changes   Json? // JSON of what changed
  createdAt DateTime    @default(now())

  @@index([action])
  @@index([entity, entityId])
  @@index([userId])
  @@index([createdAt])
  @@map("audit_logs")
}

enum AuditAction {
  USER_CREATED
  USER_UPDATED
  USER_DELETED
  ORDER_CREATED
  ORDER_UPDATED
  ORDER_CANCELLED
  PAYMENT_PROCESSED
  CUSTOMER_DATA_ACCESSED
  CUSTOMER_DATA_UPDATED
  REFERRAL_CREATED
  REFERRAL_USED
  REFERRAL_CODE_GENERATED
  REFERRAL_REWARD_ISSUED
  LOGIN_SUCCESS
  LOGIN_FAILED
  PASSWORD_RESET
}

model BlogPost {
  id               String         @id @default(cuid())
  slug             String         @unique
  locale           String         @default("en")
  title            String
  author           String         @default("Purrify Research Lab")
  excerpt          String         @db.Text
  content          String         @db.Text
  heroImageUrl     String
  heroImageAlt     String
  heroImageCredit  String?
  heroImageCaption String?
  secondaryImages  BlogImage[]
  keywords         String[]       @default([])
  metaDescription  String?
  toc              Json?
  faq              Json?
  internalLinks    Json?
  externalLinks    Json?
  ctaText          String?
  ctaUrl           String?
  topicKey         String?
  promptContext    String?        @db.Text
  rawPrompt        String?        @db.Text
  rawResponse      String?        @db.Text
  provider         String? // e.g., anthropic, openai
  modelUsed        String?
  wordCount        Int            @default(0)
  status           BlogPostStatus @default(PUBLISHED)
  scheduledFor     DateTime?
  publishedAt      DateTime?      @default(now())
  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @updatedAt

  @@index([status])
  @@index([publishedAt])
  @@index([topicKey])
  @@map("blog_posts")
}

model BlogImage {
  id        String        @id @default(cuid())
  post      BlogPost      @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId    String
  kind      BlogImageType @default(SECTION)
  url       String
  alt       String
  caption   String?
  credit    String?
  keywords  String[]      @default([])
  createdAt DateTime      @default(now())

  @@index([postId])
  @@index([kind])
  @@map("blog_images")
}

enum BlogImageType {
  HERO
  SECTION
  INFOGRAPHIC
  CTA
}

enum BlogPostStatus {
  DRAFT
  SCHEDULED
  PUBLISHED
  FAILED
}

// ===== Operations Dashboard Models =====

model Lead {
  id             String     @id @default(cuid())
  companyName    String
  phone          String?
  contactName    String?
  notes          String?    @db.Text
  status         LeadStatus @default(NEW)
  email          String?
  emailSecondary String?
  emailQuality   String?
  emailResult    String?
  emailIsFree    Boolean?
  emailIsRole    Boolean?
  street         String?
  city           String?
  province       String?
  postalCode     String?
  neighborhood   String?
  website        String?
  facebook       String?
  instagram      String?
  tiktok         String?
  youtube        String?
  twitter        String?
  openingHours   String?    @db.Text
  category       String?
  sentStatus     String?
  source         String? // csv-import, google-sheets, manual
  lastContact    DateTime?
  lastSyncedAt   DateTime?
  createdAt      DateTime   @default(now())
  updatedAt      DateTime   @updatedAt

  @@unique([companyName, city])
  @@index([status])
  @@index([city])
  @@index([province])
  @@index([category])
  @@index([createdAt])
  @@map("leads")
}

model SocialPost {
  id          String           @id @default(cuid())
  content     String           @db.Text
  platforms   String[]
  status      SocialPostStatus @default(DRAFT)
  scheduledAt DateTime?
  publishedAt DateTime?
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt

  @@index([status])
  @@index([scheduledAt])
  @@map("social_posts")
}

enum LeadStatus {
  NEW
  CONTACTED
  SAMPLE_SENT
  FOLLOWING_UP
  CONVERTED
  NOT_INTERESTED
  NO_RESPONSE
}

enum SocialPostStatus {
  DRAFT
  SCHEDULED
  PUBLISHED
  FAILED
}

// ===== Email Automation Models =====

// Cart model for abandoned cart tracking and recovery emails
model Cart {
  id              String     @id @default(cuid())
  email           String? // Email if captured during checkout
  sessionId       String     @unique // Browser session identifier
  items           Json // Cart items as JSON array
  status          CartStatus @default(ACTIVE)
  locale          String     @default("en") // For localized emails
  lastActivityAt  DateTime   @default(now())
  emailsSent      Int        @default(0) // Track number of recovery emails sent
  lastEmailSentAt DateTime? // Track when last email was sent
  recoveredAt     DateTime? // When cart was recovered (converted)
  createdAt       DateTime   @default(now())
  updatedAt       DateTime   @updatedAt

  @@index([status, lastActivityAt])
  @@index([email])
  @@index([status, emailsSent]) // For finding carts needing recovery emails
  @@map("carts")
}

enum CartStatus {
  ACTIVE // Cart is currently active
  ABANDONED // Cart has been abandoned (no activity for X hours)
  CONVERTED // Cart was converted to an order
  EXPIRED // Cart has expired (too old to recover)
}

// Email subscriber model for newsletter and marketing emails
model EmailSubscriber {
  id               String           @id @default(cuid())
  email            String           @unique
  source           String? // signup, checkout, referral, popup, footer
  locale           String           @default("en")
  status           SubscriberStatus @default(ACTIVE)
  welcomeEmailSent Boolean          @default(false)
  welcomeEmailAt   DateTime? // When welcome email was sent
  unsubscribedAt   DateTime? // When user unsubscribed
  bouncedAt        DateTime? // When email bounced
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt

  @@index([status])
  @@index([source])
  @@index([welcomeEmailSent, status]) // For finding subscribers needing welcome emails
  @@map("email_subscribers")
}

enum SubscriberStatus {
  ACTIVE // Active subscriber
  UNSUBSCRIBED // User unsubscribed
  BOUNCED // Email bounced
}

// ===== Customer LTV & Subscription Models =====

// Customer metrics for LTV tracking and segmentation
model CustomerMetrics {
  id              String   @id @default(cuid())
  email           String   @unique // Customer email as identifier
  totalOrders     Int      @default(0) // Total number of orders
  totalSpent      Float    @default(0) // Total amount spent in dollars
  averageOrderValue Float  @default(0) // Average order value
  firstOrderAt    DateTime? // Date of first order
  lastOrderAt     DateTime? // Date of most recent order
  daysSinceLastOrder Int?  // Calculated days since last order
  predictedLTV    Float?   // Predicted lifetime value
  segment         CustomerSegment @default(NEW) // Customer segment
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([segment])
  @@index([totalSpent])
  @@index([lastOrderAt])
  @@map("customer_metrics")
}

enum CustomerSegment {
  NEW // First-time customer
  RETURNING // 2-3 orders
  LOYAL // 4+ orders
  VIP // High LTV customers
  AT_RISK // Haven't ordered in 60+ days
  CHURNED // Haven't ordered in 120+ days
}

// Subscription for recurring orders
model Subscription {
  id                 String             @id @default(cuid())
  email              String // Customer email
  status             SubscriptionStatus @default(ACTIVE)
  // Subscription details
  frequency          SubscriptionFrequency @default(MONTHLY)
  nextDeliveryDate   DateTime // Next scheduled delivery
  lastDeliveryDate   DateTime? // Last delivery date
  // Product configuration
  items              SubscriptionItem[]
  // Payment
  stripeSubscriptionId String? @unique // Stripe subscription ID
  stripeCustomerId   String? // Stripe customer ID
  // Notifications
  reminderSent       Boolean  @default(false) // Has reminder been sent for next delivery
  reminderSentAt     DateTime? // When reminder was sent
  // Metadata
  pausedAt           DateTime? // When subscription was paused
  cancelledAt        DateTime? // When subscription was cancelled
  cancellationReason String? // Why customer cancelled
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
  orders             Order[] // Orders created from this subscription

  @@index([status])
  @@index([email])
  @@index([nextDeliveryDate])
  @@index([reminderSent, nextDeliveryDate]) // For finding subscriptions needing reminders
  @@map("subscriptions")
}

model SubscriptionItem {
  id             String       @id @default(cuid())
  subscription   Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)
  subscriptionId String
  product        Product      @relation(fields: [productId], references: [id])
  productId      String
  quantity       Int
  price          Float // Price at time of subscription
  createdAt      DateTime     @default(now())

  @@index([subscriptionId])
  @@index([productId])
  @@map("subscription_items")
}

enum SubscriptionStatus {
  ACTIVE // Active and will renew
  PAUSED // Temporarily paused
  CANCELLED // Cancelled by customer
  EXPIRED // Payment failed, subscription ended
}

enum SubscriptionFrequency {
  WEEKLY // Every week
  BIWEEKLY // Every 2 weeks
  MONTHLY // Every month (most common for cat litter)
  BIMONTHLY // Every 2 months
}


// ===== Affiliate Program Models =====

// AffiliateApplication - Stores pending applications before approval
model AffiliateApplication {
  id              String                      @id @default(cuid())
  name            String
  email           String                      @unique
  website         String?
  audience        String                      // Target audience description
  trafficSource   String                      // blog, youtube, instagram, etc.
  monthlyVisitors String                      // 0-1000, 1000-5000, etc.
  experience      String                      // beginner, intermediate, advanced
  message         String?                     @db.Text
  status          AffiliateApplicationStatus  @default(PENDING)
  reviewedAt      DateTime?
  reviewedBy      String?                     // Admin user ID
  rejectionReason String?
  // Email verification fields
  emailVerified   Boolean                     @default(false)
  verifyToken     String?                     @unique
  verifyExpiresAt DateTime?
  createdAt       DateTime                    @default(now())
  updatedAt       DateTime                    @updatedAt

  @@index([status])
  @@index([createdAt])
  @@index([email])
  @@index([verifyToken])
  @@map("affiliate_applications")
}

enum AffiliateApplicationStatus {
  PENDING
  APPROVED
  REJECTED
}

// Affiliate - Approved affiliate accounts with credentials
model Affiliate {
  id               String          @id @default(cuid())
  code             String          @unique    // e.g., "JOHN-A1B2"
  name             String
  email            String          @unique
  passwordHash     String                     // bcrypt hashed
  website          String?
  status           AffiliateStatus @default(ACTIVE)
  // Stats (denormalized for dashboard performance)
  totalClicks      Int             @default(0)
  totalConversions Int             @default(0)
  totalEarnings    Float           @default(0)
  pendingEarnings  Float           @default(0)
  availableBalance Float           @default(0)
  // Tiered Commission System (Hormozi Enhancement)
  tier                     AffiliateTier @default(STARTER)
  commissionRate           Float         @default(0.20)  // 20% for STARTER
  currentMonthSales        Int           @default(0)
  lastMonthSales           Int           @default(0)
  partnerQualifyingMonths  Int           @default(0)     // Months with 5+ sales
  lastMonthResetAt         DateTime?                     // For lazy monthly reset
  lastRewardMonth          String?                       // "YYYY-MM" for Sell 3 Get Free tracking
  // Activation (Starter Kit Purchase)
  activatedAt              DateTime?                     // When starter kit purchased
  starterKitOrderId        String?                       // Stripe order ID
  // Payment info
  payoutMethod     PayoutMethod    @default(PAYPAL)
  payoutEmail      String?                    // PayPal email or E-Transfer email
  // Metadata
  applicationId    String?         @unique    // Link to original application
  lastLoginAt      DateTime?
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt
  // Relations
  clicks           AffiliateClick[]
  conversions      AffiliateConversion[]
  payouts          AffiliatePayout[]

  @@index([code])
  @@index([status])
  @@index([email])
  @@index([tier])
  @@map("affiliates")
}

enum AffiliateStatus {
  ACTIVE
  SUSPENDED
  TERMINATED
}

enum PayoutMethod {
  PAYPAL
  ETRANSFER
}

enum AffiliateTier {
  STARTER   // 20% commission - default tier
  ACTIVE    // 25% commission - after 3 cleared sales
  PARTNER   // 30% commission - 5+ sales/month for 2 consecutive months
}

// AffiliateClick - Tracks clicks on affiliate links
model AffiliateClick {
  id          String    @id @default(cuid())
  affiliateId String
  affiliate   Affiliate @relation(fields: [affiliateId], references: [id], onDelete: Cascade)
  // Tracking data
  ipHash      String                // SHA256 of IP (privacy)
  userAgent   String?   @db.Text
  referrer    String?               // Where click came from
  landingPage String                // Which page they landed on
  // Session tracking
  sessionId   String                // For attributing conversion
  convertedAt DateTime?             // If this click led to purchase
  orderId     String?               // Order if converted
  createdAt   DateTime  @default(now())

  @@index([affiliateId])
  @@index([sessionId])
  @@index([createdAt])
  @@index([convertedAt])
  @@map("affiliate_clicks")
}

// AffiliateConversion - Tracks successful conversions (purchases)
model AffiliateConversion {
  id               String            @id @default(cuid())
  affiliateId      String
  affiliate        Affiliate         @relation(fields: [affiliateId], references: [id], onDelete: Cascade)
  orderId          String            @unique
  orderSubtotal    Float                       // Order subtotal (excl. tax/shipping)
  commissionRate   Float             @default(0.30)  // 30%
  commissionAmount Float                       // Calculated commission
  status           ConversionStatus  @default(PENDING)
  // Timing
  purchasedAt      DateTime          @default(now())
  clearedAt        DateTime?                   // When moved to available (30 days)
  voidedAt         DateTime?                   // If refunded
  voidReason       String?
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt

  @@index([affiliateId])
  @@index([status])
  @@index([purchasedAt])
  @@index([orderId])
  @@map("affiliate_conversions")
}

enum ConversionStatus {
  PENDING    // Within 30-day hold period
  CLEARED    // Available for payout
  VOIDED     // Refunded or cancelled
  PAID       // Included in a payout
}

// AffiliatePayout - Tracks payout requests and history
model AffiliatePayout {
  id             String        @id @default(cuid())
  affiliateId    String
  affiliate      Affiliate     @relation(fields: [affiliateId], references: [id], onDelete: Cascade)
  amount         Float
  method         PayoutMethod
  payoutEmail    String                    // Email used for this payout
  status         PayoutStatus  @default(PENDING)
  // Processing
  requestedAt    DateTime      @default(now())
  processedAt    DateTime?
  processedBy    String?                   // Admin who processed
  transactionRef String?                   // PayPal/E-Transfer reference
  notes          String?       @db.Text
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  @@index([affiliateId])
  @@index([status])
  @@index([requestedAt])
  @@map("affiliate_payouts")
}

enum PayoutStatus {
  PENDING     // Requested, awaiting processing
  PROCESSING  // Admin is processing
  COMPLETED   // Payout sent
  REJECTED    // Rejected by admin
}
